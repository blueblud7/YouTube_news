#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Google Colab ìŠ¤íƒ€ì¼ì˜ ê°„ë‹¨í•œ OAuth ì¸ì¦ í•¸ë“¤ëŸ¬
"""

import streamlit as st
import os
import json
import webbrowser
import requests
from datetime import datetime, timedelta
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from config import get_youtube_api_key

class ColabStyleAuth:
    def __init__(self):
        self.youtube_service = None
        self.authenticated = False
        self.access_token = None
        
    def authenticate_colab_style(self):
        """Google Colab ìŠ¤íƒ€ì¼ì˜ ê°„ë‹¨í•œ OAuth ì¸ì¦"""
        try:
            st.markdown("### ğŸ” êµ¬ê¸€ ë¡œê·¸ì¸ (Colab ìŠ¤íƒ€ì¼)")
            st.markdown("ì•„ë˜ ë‹¨ê³„ë¥¼ ë”°ë¼ êµ¬ê¸€ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•˜ì„¸ìš”.")
            
            # 1ë‹¨ê³„: ì¸ì¦ URL ìƒì„±
            client_id = "your-client-id.apps.googleusercontent.com"
            scope = "https://www.googleapis.com/auth/youtube.readonly"
            
            # ì¸ì¦ URL ìƒì„±
            auth_url = f"https://accounts.google.com/o/oauth2/auth?client_id={client_id}&scope={scope}&response_type=code&access_type=offline&redirect_uri=urn:ietf:wg:oauth:2.0:oob"
            
            st.markdown("#### 1ë‹¨ê³„: ì¸ì¦ URL í´ë¦­")
            st.markdown(f"**ì•„ë˜ ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ êµ¬ê¸€ ë¡œê·¸ì¸ í˜ì´ì§€ë¥¼ ì—´ì–´ì£¼ì„¸ìš”:**")
            
            # í´ë¦­ ê°€ëŠ¥í•œ ë§í¬
            st.markdown(f"[ğŸ”— êµ¬ê¸€ ë¡œê·¸ì¸ í˜ì´ì§€ ì—´ê¸°]({auth_url})")
            
            # ë˜ëŠ” ë²„íŠ¼ìœ¼ë¡œ ì—´ê¸°
            if st.button("ğŸŒ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ê¸°"):
                webbrowser.open(auth_url)
                st.success("ë¸Œë¼ìš°ì €ì—ì„œ êµ¬ê¸€ ë¡œê·¸ì¸ í˜ì´ì§€ê°€ ì—´ë ¸ìŠµë‹ˆë‹¤!")
            
            st.markdown("#### 2ë‹¨ê³„: ì¸ì¦ ì½”ë“œ ë³µì‚¬")
            st.markdown("ë¡œê·¸ì¸ í›„ ë‚˜íƒ€ë‚˜ëŠ” ì¸ì¦ ì½”ë“œë¥¼ ë³µì‚¬í•˜ì„¸ìš”.")
            
            # 3ë‹¨ê³„: ì¸ì¦ ì½”ë“œ ì…ë ¥
            st.markdown("#### 3ë‹¨ê³„: ì¸ì¦ ì½”ë“œ ì…ë ¥")
            auth_code = st.text_input("ì¸ì¦ ì½”ë“œë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”:", type="password", help="êµ¬ê¸€ ë¡œê·¸ì¸ í˜ì´ì§€ì—ì„œ ë°›ì€ ì¸ì¦ ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”")
            
            if auth_code:
                if st.button("ğŸ”‘ ë¡œê·¸ì¸"):
                    # í† í° êµí™˜
                    token_url = "https://oauth2.googleapis.com/token"
                    token_data = {
                        "client_id": client_id,
                        "client_secret": "your-client-secret",
                        "code": auth_code,
                        "grant_type": "authorization_code",
                        "redirect_uri": "urn:ietf:wg:oauth:2.0:oob"
                    }
                    
                    with st.spinner("ì¸ì¦ ì¤‘..."):
                        response = requests.post(token_url, data=token_data)
                    
                    if response.status_code == 200:
                        token_info = response.json()
                        self.access_token = token_info.get("access_token")
                        
                        # YouTube API ì„œë¹„ìŠ¤ ìƒì„±
                        self.youtube_service = build('youtube', 'v3', credentials=self.access_token)
                        self.authenticated = True
                        
                        st.success("âœ… êµ¬ê¸€ ë¡œê·¸ì¸ ì„±ê³µ!")
                        st.balloons()
                        return True
                    else:
                        st.error("âŒ ì¸ì¦ ì½”ë“œê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.")
                        st.error(f"ì˜¤ë¥˜: {response.text}")
                        return False
            
            return False
                
        except Exception as e:
            st.error(f"OAuth ì¸ì¦ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return False
    
    def authenticate_simple(self):
        """ê°„ë‹¨í•œ ì¸ì¦ (API í‚¤ë§Œ ì‚¬ìš©)"""
        try:
            api_key = get_youtube_api_key()
            if not api_key:
                st.error("YouTube API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
                return False
            
            # API í‚¤ë¡œ YouTube ì„œë¹„ìŠ¤ ìƒì„±
            self.youtube_service = build('youtube', 'v3', developerKey=api_key)
            self.authenticated = True
            return True
            
        except Exception as e:
            st.error(f"ê°„ë‹¨ ì¸ì¦ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return False
    
    def search_videos_by_keyword(self, keyword, time_filter='1w', max_results=50):
        """í‚¤ì›Œë“œë¡œ ìµœì‹  ë™ì˜ìƒì„ ê²€ìƒ‰í•©ë‹ˆë‹¤."""
        if not self.youtube_service:
            if not self.authenticate_simple():
                return []
        
        try:
            # ì‹œê°„ í•„í„° ì„¤ì •
            published_after = None
            if time_filter == '1d':
                published_after = datetime.now() - timedelta(days=1)
            elif time_filter == '1w':
                published_after = datetime.now() - timedelta(weeks=1)
            elif time_filter == '1m':
                published_after = datetime.now() - timedelta(days=30)
            elif time_filter == 'latest':
                published_after = datetime.now() - timedelta(hours=6)
            
            published_after_str = published_after.isoformat() + 'Z' if published_after else None
            
            videos = []
            next_page_token = None
            
            with st.spinner(f"'{keyword}' í‚¤ì›Œë“œë¡œ ë™ì˜ìƒì„ ê²€ìƒ‰ ì¤‘..."):
                while len(videos) < max_results:
                    request = self.youtube_service.search().list(
                        part='snippet',
                        q=keyword,
                        type='video',
                        order='date',
                        maxResults=min(50, max_results - len(videos)),
                        pageToken=next_page_token,
                        publishedAfter=published_after_str
                    )
                    
                    response = request.execute()
                    
                    for item in response['items']:
                        video = {
                            'video_id': item['id']['videoId'],
                            'title': item['snippet']['title'],
                            'description': item['snippet']['description'],
                            'channel_id': item['snippet']['channelId'],
                            'channel_title': item['snippet']['channelTitle'],
                            'published_at': item['snippet']['publishedAt'],
                            'thumbnail_url': item['snippet']['thumbnails']['medium']['url'],
                            'url': f"https://www.youtube.com/watch?v={item['id']['videoId']}"
                        }
                        videos.append(video)
                    
                    next_page_token = response.get('nextPageToken')
                    if not next_page_token:
                        break
            
            return videos
            
        except HttpError as e:
            st.error(f"ë™ì˜ìƒ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []
        except Exception as e:
            st.error(f"ë™ì˜ìƒ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []
    
    def get_subscriptions(self, max_results=50):
        """ì‚¬ìš©ìì˜ êµ¬ë… ì±„ë„ ëª©ë¡ì„ ê°€ì ¸ì˜µë‹ˆë‹¤."""
        if not self.authenticated:
            st.warning("ë¨¼ì € êµ¬ê¸€ ë¡œê·¸ì¸ì„ í•´ì£¼ì„¸ìš”.")
            return []
        
        try:
            subscriptions = []
            next_page_token = None
            
            with st.spinner("êµ¬ë… ì±„ë„ ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘..."):
                while len(subscriptions) < max_results:
                    request = self.youtube_service.subscriptions().list(
                        part='snippet',
                        mine=True,
                        maxResults=min(50, max_results - len(subscriptions)),
                        pageToken=next_page_token
                    )
                    
                    response = request.execute()
                    
                    for item in response['items']:
                        subscription = {
                            'channel_id': item['snippet']['resourceId']['channelId'],
                            'channel_title': item['snippet']['title'],
                            'channel_description': item['snippet']['description'],
                            'thumbnail_url': item['snippet']['thumbnails']['default']['url'],
                            'subscribed_at': item['snippet']['publishedAt']
                        }
                        subscriptions.append(subscription)
                    
                    next_page_token = response.get('nextPageToken')
                    if not next_page_token:
                        break
            
            return subscriptions
            
        except HttpError as e:
            st.error(f"êµ¬ë… ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []
    
    def get_subscription_videos(self, time_filter='1w', max_results=50):
        """êµ¬ë… ì±„ë„ì˜ ìµœì‹  ë™ì˜ìƒì„ ê°€ì ¸ì˜µë‹ˆë‹¤."""
        if not self.authenticated:
            st.warning("ë¨¼ì € êµ¬ê¸€ ë¡œê·¸ì¸ì„ í•´ì£¼ì„¸ìš”.")
            return []
        
        try:
            # êµ¬ë… ì±„ë„ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            subscriptions = self.get_subscriptions(max_results=100)
            if not subscriptions:
                return []
            
            # ì‹œê°„ í•„í„° ì„¤ì •
            published_after = None
            if time_filter == '1d':
                published_after = datetime.now() - timedelta(days=1)
            elif time_filter == '1w':
                published_after = datetime.now() - timedelta(weeks=1)
            elif time_filter == '1m':
                published_after = datetime.now() - timedelta(days=30)
            elif time_filter == 'latest':
                published_after = datetime.now() - timedelta(hours=6)
            
            published_after_str = published_after.isoformat() + 'Z' if published_after else None
            
            all_videos = []
            
            # ì§„í–‰ë¥  í‘œì‹œ
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            # ê° êµ¬ë… ì±„ë„ì˜ ìµœì‹  ë™ì˜ìƒ ê°€ì ¸ì˜¤ê¸°
            for i, subscription in enumerate(subscriptions):
                status_text.text(f"ì±„ë„ '{subscription['channel_title']}'ì˜ ë™ì˜ìƒì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘... ({i+1}/{len(subscriptions)})")
                
                try:
                    request = self.youtube_service.search().list(
                        part='snippet',
                        channelId=subscription['channel_id'],
                        type='video',
                        order='date',
                        maxResults=10,  # ì±„ë„ë‹¹ ìµœëŒ€ 10ê°œ
                        publishedAfter=published_after_str
                    )
                    
                    response = request.execute()
                    
                    for item in response['items']:
                        video = {
                            'video_id': item['id']['videoId'],
                            'title': item['snippet']['title'],
                            'description': item['snippet']['description'],
                            'channel_id': item['snippet']['channelId'],
                            'channel_title': item['snippet']['channelTitle'],
                            'published_at': item['snippet']['publishedAt'],
                            'thumbnail_url': item['snippet']['thumbnails']['medium']['url'],
                            'url': f"https://www.youtube.com/watch?v={item['id']['videoId']}",
                            'subscription': subscription['channel_title']
                        }
                        all_videos.append(video)
                        
                        if len(all_videos) >= max_results:
                            break
                    
                    if len(all_videos) >= max_results:
                        break
                        
                except HttpError as e:
                    st.warning(f"ì±„ë„ {subscription['channel_title']}ì˜ ë™ì˜ìƒ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: {str(e)}")
                    continue
                
                # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                progress_bar.progress((i + 1) / len(subscriptions))
            
            status_text.text("ì™„ë£Œ!")
            progress_bar.empty()
            
            # ë°œí–‰ì¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
            all_videos.sort(key=lambda x: x['published_at'], reverse=True)
            return all_videos[:max_results]
            
        except HttpError as e:
            st.error(f"êµ¬ë… ë™ì˜ìƒ ê°€ì ¸ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []

# ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
colab_auth_handler = ColabStyleAuth() 