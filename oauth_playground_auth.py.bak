#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Google OAuth Playgroundë¥¼ í™œìš©í•œ ê°„ë‹¨í•œ ì¸ì¦ í•¸ë“¤ëŸ¬
"""

import streamlit as st
import os
import json
import webbrowser
import requests
from datetime import datetime, timedelta
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from config import get_youtube_api_key

class OAuthPlaygroundAuth:
    def __init__(self):
        self.youtube_service = None
        self.authenticated = False
        self.access_token = None
        
    def authenticate_with_playground(self):
        """Google OAuth Playgroundë¥¼ í™œìš©í•œ ê°„ë‹¨í•œ ì¸ì¦"""
        try:
            st.markdown("### ğŸ” êµ¬ê¸€ ë¡œê·¸ì¸ (OAuth Playground)")
            st.markdown("Google OAuth Playgroundë¥¼ ì‚¬ìš©í•˜ì—¬ ê°„ë‹¨í•˜ê²Œ ë¡œê·¸ì¸í•˜ì„¸ìš”.")
            
            # OAuth Playground URL
            playground_url = "https://developers.google.com/oauthplayground/"
            
            st.markdown("#### ë°©ë²• 1: Google OAuth Playground ì‚¬ìš©")
            st.markdown("1. ì•„ë˜ ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ Google OAuth Playgroundë¥¼ ì—½ë‹ˆë‹¤.")
            st.markdown("2. **YouTube Data API v3**ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.")
            st.markdown("3. **Authorize APIs** ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ë¡œê·¸ì¸í•©ë‹ˆë‹¤.")
            st.markdown("4. **Exchange authorization code for tokens** ë²„íŠ¼ì„ í´ë¦­í•©ë‹ˆë‹¤.")
            st.markdown("5. **Access token**ì„ ë³µì‚¬í•˜ì—¬ ì•„ë˜ì— ë¶™ì—¬ë„£ìŠµë‹ˆë‹¤.")
            
            # OAuth Playground ë§í¬
            if st.button("ğŸŒ Google OAuth Playground ì—´ê¸°"):
                webbrowser.open(playground_url)
                st.success("Google OAuth Playgroundê°€ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ë ¸ìŠµë‹ˆë‹¤!")
            
            st.markdown("#### Access Token ì…ë ¥")
            access_token = st.text_input("Access Tokenì„ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”:", type="password", 
                                       help="OAuth Playgroundì—ì„œ ë°›ì€ Access Tokenì„ ì…ë ¥í•˜ì„¸ìš”")
            
            if access_token:
                if st.button("ğŸ”‘ ë¡œê·¸ì¸"):
                    try:
                        # Access Tokenìœ¼ë¡œ YouTube API ì„œë¹„ìŠ¤ ìƒì„±
                        self.youtube_service = build('youtube', 'v3', credentials=access_token)
                        self.access_token = access_token
                        self.authenticated = True
                        
                        # ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ ìš”ì²­
                        test_request = self.youtube_service.channels().list(
                            part='snippet',
                            mine=True
                        )
                        test_response = test_request.execute()
                        
                        st.success("âœ… êµ¬ê¸€ ë¡œê·¸ì¸ ì„±ê³µ!")
                        st.balloons()
                        return True
                        
                    except Exception as e:
                        st.error(f"âŒ Access Tokenì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {str(e)}")
                        return False
            
            return False
                
        except Exception as e:
            st.error(f"OAuth ì¸ì¦ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return False
    
    def authenticate_simple(self):
        """ê°„ë‹¨í•œ ì¸ì¦ (API í‚¤ë§Œ ì‚¬ìš©)"""
        try:
            api_key = get_youtube_api_key()
            if not api_key:
                st.error("YouTube API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
                return False
            
            # API í‚¤ë¡œ YouTube ì„œë¹„ìŠ¤ ìƒì„±
            self.youtube_service = build('youtube', 'v3', developerKey=api_key)
            self.authenticated = True
            return True
            
        except Exception as e:
            st.error(f"ê°„ë‹¨ ì¸ì¦ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return False
    
    def search_videos_by_keyword(self, keyword, time_filter='1w', max_results=50):
        """í‚¤ì›Œë“œë¡œ ìµœì‹  ë™ì˜ìƒì„ ê²€ìƒ‰í•©ë‹ˆë‹¤."""
        if not self.youtube_service:
            if not self.authenticate_simple():
                return []
        
        try:
            # ì‹œê°„ í•„í„° ì„¤ì •
            published_after = None
            if time_filter == '1d':
                published_after = datetime.now() - timedelta(days=1)
            elif time_filter == '1w':
                published_after = datetime.now() - timedelta(weeks=1)
            elif time_filter == '1m':
                published_after = datetime.now() - timedelta(days=30)
            elif time_filter == 'latest':
                published_after = datetime.now() - timedelta(hours=6)
            
            published_after_str = published_after.isoformat() + 'Z' if published_after else None
            
            videos = []
            next_page_token = None
            
            with st.spinner(f"'{keyword}' í‚¤ì›Œë“œë¡œ ë™ì˜ìƒì„ ê²€ìƒ‰ ì¤‘..."):
                while len(videos) < max_results:
                    request = self.youtube_service.search().list(
                        part='snippet',
                        q=keyword,
                        type='video',
                        order='date',
                        maxResults=min(50, max_results - len(videos)),
                        pageToken=next_page_token,
                        publishedAfter=published_after_str
                    )
                    
                    response = request.execute()
                    
                    for item in response['items']:
                        video = {
                            'video_id': item['id']['videoId'],
                            'title': item['snippet']['title'],
                            'description': item['snippet']['description'],
                            'channel_id': item['snippet']['channelId'],
                            'channel_title': item['snippet']['channelTitle'],
                            'published_at': item['snippet']['publishedAt'],
                            'thumbnail_url': item['snippet']['thumbnails']['medium']['url'],
                            'url': f"https://www.youtube.com/watch?v={item['id']['videoId']}"
                        }
                        videos.append(video)
                    
                    next_page_token = response.get('nextPageToken')
                    if not next_page_token:
                        break
            
            return videos
            
        except HttpError as e:
            st.error(f"ë™ì˜ìƒ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []
        except Exception as e:
            st.error(f"ë™ì˜ìƒ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []
    
    def get_subscriptions(self, max_results=50):
        """ì‚¬ìš©ìì˜ êµ¬ë… ì±„ë„ ëª©ë¡ì„ ê°€ì ¸ì˜µë‹ˆë‹¤."""
        if not self.authenticated:
            st.warning("ë¨¼ì € êµ¬ê¸€ ë¡œê·¸ì¸ì„ í•´ì£¼ì„¸ìš”.")
            return []
        
        try:
            subscriptions = []
            next_page_token = None
            
            with st.spinner("êµ¬ë… ì±„ë„ ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘..."):
                while len(subscriptions) < max_results:
                    request = self.youtube_service.subscriptions().list(
                        part='snippet',
                        mine=True,
                        maxResults=min(50, max_results - len(subscriptions)),
                        pageToken=next_page_token
                    )
                    
                    response = request.execute()
                    
                    for item in response['items']:
                        subscription = {
                            'channel_id': item['snippet']['resourceId']['channelId'],
                            'channel_title': item['snippet']['title'],
                            'channel_description': item['snippet']['description'],
                            'thumbnail_url': item['snippet']['thumbnails']['default']['url'],
                            'subscribed_at': item['snippet']['publishedAt']
                        }
                        subscriptions.append(subscription)
                    
                    next_page_token = response.get('nextPageToken')
                    if not next_page_token:
                        break
            
            return subscriptions
            
        except HttpError as e:
            st.error(f"êµ¬ë… ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []
    
    def get_subscription_videos(self, time_filter='1w', max_results=50):
        """êµ¬ë… ì±„ë„ì˜ ìµœì‹  ë™ì˜ìƒì„ ê°€ì ¸ì˜µë‹ˆë‹¤."""
        if not self.authenticated:
            st.warning("ë¨¼ì € êµ¬ê¸€ ë¡œê·¸ì¸ì„ í•´ì£¼ì„¸ìš”.")
            return []
        
        try:
            # êµ¬ë… ì±„ë„ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            subscriptions = self.get_subscriptions(max_results=100)
            if not subscriptions:
                return []
            
            # ì‹œê°„ í•„í„° ì„¤ì •
            published_after = None
            if time_filter == '1d':
                published_after = datetime.now() - timedelta(days=1)
            elif time_filter == '1w':
                published_after = datetime.now() - timedelta(weeks=1)
            elif time_filter == '1m':
                published_after = datetime.now() - timedelta(days=30)
            elif time_filter == 'latest':
                published_after = datetime.now() - timedelta(hours=6)
            
            published_after_str = published_after.isoformat() + 'Z' if published_after else None
            
            all_videos = []
            
            # ì§„í–‰ë¥  í‘œì‹œ
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            # ê° êµ¬ë… ì±„ë„ì˜ ìµœì‹  ë™ì˜ìƒ ê°€ì ¸ì˜¤ê¸°
            for i, subscription in enumerate(subscriptions):
                status_text.text(f"ì±„ë„ '{subscription['channel_title']}'ì˜ ë™ì˜ìƒì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘... ({i+1}/{len(subscriptions)})")
                
                try:
                    request = self.youtube_service.search().list(
                        part='snippet',
                        channelId=subscription['channel_id'],
                        type='video',
                        order='date',
                        maxResults=10,  # ì±„ë„ë‹¹ ìµœëŒ€ 10ê°œ
                        publishedAfter=published_after_str
                    )
                    
                    response = request.execute()
                    
                    for item in response['items']:
                        video = {
                            'video_id': item['id']['videoId'],
                            'title': item['snippet']['title'],
                            'description': item['snippet']['description'],
                            'channel_id': item['snippet']['channelId'],
                            'channel_title': item['snippet']['channelTitle'],
                            'published_at': item['snippet']['publishedAt'],
                            'thumbnail_url': item['snippet']['thumbnails']['medium']['url'],
                            'url': f"https://www.youtube.com/watch?v={item['id']['videoId']}",
                            'subscription': subscription['channel_title']
                        }
                        all_videos.append(video)
                        
                        if len(all_videos) >= max_results:
                            break
                    
                    if len(all_videos) >= max_results:
                        break
                        
                except HttpError as e:
                    st.warning(f"ì±„ë„ {subscription['channel_title']}ì˜ ë™ì˜ìƒ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: {str(e)}")
                    continue
                
                # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                progress_bar.progress((i + 1) / len(subscriptions))
            
            status_text.text("ì™„ë£Œ!")
            progress_bar.empty()
            
            # ë°œí–‰ì¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
            all_videos.sort(key=lambda x: x['published_at'], reverse=True)
            return all_videos[:max_results]
            
        except HttpError as e:
            st.error(f"êµ¬ë… ë™ì˜ìƒ ê°€ì ¸ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []

# ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
playground_auth_handler = OAuthPlaygroundAuth() 