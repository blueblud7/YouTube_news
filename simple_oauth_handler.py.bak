#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
ì›¹ ê¸°ë°˜ OAuth í”Œë¡œìš°ë¥¼ ì‚¬ìš©í•œ ê°„ë‹¨í•œ êµ¬ê¸€ ì¸ì¦ í•¸ë“¤ëŸ¬
"""

import streamlit as st
import os
import json
import webbrowser
import requests
from datetime import datetime, timedelta
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from config import get_youtube_api_key

class SimpleOAuthHandler:
    def __init__(self):
        self.youtube_service = None
        self.authenticated = False
        self.access_token = None
        
    def authenticate_with_web_flow(self):
        """ì›¹ ê¸°ë°˜ OAuth í”Œë¡œìš°ë¥¼ ì‚¬ìš©í•œ êµ¬ê¸€ ì¸ì¦"""
        try:
            # OAuth 2.0 ì„¤ì •
            client_id = "your-client-id.apps.googleusercontent.com"
            redirect_uri = "http://localhost:8501"
            scope = "https://www.googleapis.com/auth/youtube.readonly"
            
            # ì¸ì¦ URL ìƒì„±
            auth_url = f"https://accounts.google.com/o/oauth2/auth?client_id={client_id}&redirect_uri={redirect_uri}&scope={scope}&response_type=code&access_type=offline"
            
            st.markdown("### ğŸ” êµ¬ê¸€ ë¡œê·¸ì¸")
            st.markdown("ì•„ë˜ ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ êµ¬ê¸€ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•˜ì„¸ìš”.")
            
            # ë¡œê·¸ì¸ ë²„íŠ¼
            if st.button("ğŸŒ êµ¬ê¸€ ë¡œê·¸ì¸ í˜ì´ì§€ ì—´ê¸°"):
                webbrowser.open(auth_url)
                st.info("ë¸Œë¼ìš°ì €ì—ì„œ êµ¬ê¸€ ë¡œê·¸ì¸ í˜ì´ì§€ê°€ ì—´ë ¸ìŠµë‹ˆë‹¤. ë¡œê·¸ì¸ í›„ ì¸ì¦ ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”.")
            
            # ì¸ì¦ ì½”ë“œ ì…ë ¥
            auth_code = st.text_input("ì¸ì¦ ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”:", type="password")
            
            if auth_code:
                # í† í° êµí™˜
                token_url = "https://oauth2.googleapis.com/token"
                token_data = {
                    "client_id": client_id,
                    "client_secret": "your-client-secret",
                    "code": auth_code,
                    "grant_type": "authorization_code",
                    "redirect_uri": redirect_uri
                }
                
                response = requests.post(token_url, data=token_data)
                
                if response.status_code == 200:
                    token_info = response.json()
                    self.access_token = token_info.get("access_token")
                    
                    # YouTube API ì„œë¹„ìŠ¤ ìƒì„±
                    self.youtube_service = build('youtube', 'v3', credentials=self.access_token)
                    self.authenticated = True
                    
                    st.success("âœ… êµ¬ê¸€ ë¡œê·¸ì¸ ì„±ê³µ!")
                    return True
                else:
                    st.error("âŒ ì¸ì¦ ì½”ë“œê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
                    return False
            
            return False
                
        except Exception as e:
            st.error(f"OAuth ì¸ì¦ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return False
    
    def authenticate_simple(self):
        """ê°„ë‹¨í•œ ì¸ì¦ (API í‚¤ë§Œ ì‚¬ìš©)"""
        try:
            api_key = get_youtube_api_key()
            if not api_key:
                st.error("YouTube API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
                return False
            
            # API í‚¤ë¡œ YouTube ì„œë¹„ìŠ¤ ìƒì„±
            self.youtube_service = build('youtube', 'v3', developerKey=api_key)
            self.authenticated = True
            return True
            
        except Exception as e:
            st.error(f"ê°„ë‹¨ ì¸ì¦ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return False
    
    def search_videos_by_keyword(self, keyword, time_filter='1w', max_results=50):
        """í‚¤ì›Œë“œë¡œ ìµœì‹  ë™ì˜ìƒì„ ê²€ìƒ‰í•©ë‹ˆë‹¤."""
        if not self.youtube_service:
            if not self.authenticate_simple():
                return []
        
        try:
            # ì‹œê°„ í•„í„° ì„¤ì •
            published_after = None
            if time_filter == '1d':
                published_after = datetime.now() - timedelta(days=1)
            elif time_filter == '1w':
                published_after = datetime.now() - timedelta(weeks=1)
            elif time_filter == '1m':
                published_after = datetime.now() - timedelta(days=30)
            elif time_filter == 'latest':
                published_after = datetime.now() - timedelta(hours=6)
            
            published_after_str = published_after.isoformat() + 'Z' if published_after else None
            
            videos = []
            next_page_token = None
            
            while len(videos) < max_results:
                request = self.youtube_service.search().list(
                    part='snippet',
                    q=keyword,
                    type='video',
                    order='date',
                    maxResults=min(50, max_results - len(videos)),
                    pageToken=next_page_token,
                    publishedAfter=published_after_str
                )
                
                response = request.execute()
                
                for item in response['items']:
                    video = {
                        'video_id': item['id']['videoId'],
                        'title': item['snippet']['title'],
                        'description': item['snippet']['description'],
                        'channel_id': item['snippet']['channelId'],
                        'channel_title': item['snippet']['channelTitle'],
                        'published_at': item['snippet']['publishedAt'],
                        'thumbnail_url': item['snippet']['thumbnails']['medium']['url'],
                        'url': f"https://www.youtube.com/watch?v={item['id']['videoId']}"
                    }
                    videos.append(video)
                
                next_page_token = response.get('nextPageToken')
                if not next_page_token:
                    break
            
            return videos
            
        except HttpError as e:
            st.error(f"ë™ì˜ìƒ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []
        except Exception as e:
            st.error(f"ë™ì˜ìƒ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []
    
    def get_subscriptions(self, max_results=50):
        """ì‚¬ìš©ìì˜ êµ¬ë… ì±„ë„ ëª©ë¡ì„ ê°€ì ¸ì˜µë‹ˆë‹¤."""
        if not self.authenticated:
            st.warning("ë¨¼ì € êµ¬ê¸€ ë¡œê·¸ì¸ì„ í•´ì£¼ì„¸ìš”.")
            return []
        
        try:
            subscriptions = []
            next_page_token = None
            
            while len(subscriptions) < max_results:
                request = self.youtube_service.subscriptions().list(
                    part='snippet',
                    mine=True,
                    maxResults=min(50, max_results - len(subscriptions)),
                    pageToken=next_page_token
                )
                
                response = request.execute()
                
                for item in response['items']:
                    subscription = {
                        'channel_id': item['snippet']['resourceId']['channelId'],
                        'channel_title': item['snippet']['title'],
                        'channel_description': item['snippet']['description'],
                        'thumbnail_url': item['snippet']['thumbnails']['default']['url'],
                        'subscribed_at': item['snippet']['publishedAt']
                    }
                    subscriptions.append(subscription)
                
                next_page_token = response.get('nextPageToken')
                if not next_page_token:
                    break
            
            return subscriptions
            
        except HttpError as e:
            st.error(f"êµ¬ë… ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []
    
    def get_subscription_videos(self, time_filter='1w', max_results=50):
        """êµ¬ë… ì±„ë„ì˜ ìµœì‹  ë™ì˜ìƒì„ ê°€ì ¸ì˜µë‹ˆë‹¤."""
        if not self.authenticated:
            st.warning("ë¨¼ì € êµ¬ê¸€ ë¡œê·¸ì¸ì„ í•´ì£¼ì„¸ìš”.")
            return []
        
        try:
            # êµ¬ë… ì±„ë„ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            subscriptions = self.get_subscriptions(max_results=100)
            if not subscriptions:
                return []
            
            # ì‹œê°„ í•„í„° ì„¤ì •
            published_after = None
            if time_filter == '1d':
                published_after = datetime.now() - timedelta(days=1)
            elif time_filter == '1w':
                published_after = datetime.now() - timedelta(weeks=1)
            elif time_filter == '1m':
                published_after = datetime.now() - timedelta(days=30)
            elif time_filter == 'latest':
                published_after = datetime.now() - timedelta(hours=6)
            
            published_after_str = published_after.isoformat() + 'Z' if published_after else None
            
            all_videos = []
            
            # ê° êµ¬ë… ì±„ë„ì˜ ìµœì‹  ë™ì˜ìƒ ê°€ì ¸ì˜¤ê¸°
            for subscription in subscriptions:
                try:
                    request = self.youtube_service.search().list(
                        part='snippet',
                        channelId=subscription['channel_id'],
                        type='video',
                        order='date',
                        maxResults=10,  # ì±„ë„ë‹¹ ìµœëŒ€ 10ê°œ
                        publishedAfter=published_after_str
                    )
                    
                    response = request.execute()
                    
                    for item in response['items']:
                        video = {
                            'video_id': item['id']['videoId'],
                            'title': item['snippet']['title'],
                            'description': item['snippet']['description'],
                            'channel_id': item['snippet']['channelId'],
                            'channel_title': item['snippet']['channelTitle'],
                            'published_at': item['snippet']['publishedAt'],
                            'thumbnail_url': item['snippet']['thumbnails']['medium']['url'],
                            'url': f"https://www.youtube.com/watch?v={item['id']['videoId']}",
                            'subscription': subscription['channel_title']
                        }
                        all_videos.append(video)
                        
                        if len(all_videos) >= max_results:
                            break
                    
                    if len(all_videos) >= max_results:
                        break
                        
                except HttpError as e:
                    st.warning(f"ì±„ë„ {subscription['channel_title']}ì˜ ë™ì˜ìƒ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: {str(e)}")
                    continue
            
            # ë°œí–‰ì¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
            all_videos.sort(key=lambda x: x['published_at'], reverse=True)
            return all_videos[:max_results]
            
        except HttpError as e:
            st.error(f"êµ¬ë… ë™ì˜ìƒ ê°€ì ¸ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return []

# ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
simple_auth_handler = SimpleOAuthHandler() 