#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
YouTube RSS ÌîºÎìú ÏàòÏßë ÏãúÏä§ÌÖú
API Ìï†ÎãπÎüâ ÏóÜÏù¥ Ï±ÑÎÑê ÏóÖÎç∞Ïù¥Ìä∏ ÏàòÏßë
"""

import feedparser
import requests
import sqlite3
import re
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import streamlit as st

class YouTubeRSSCollector:
    def __init__(self, db_path: str = "youtube_news.db"):
        self.db_path = db_path
        self.base_rss_url = "https://www.youtube.com/feeds/videos.xml"
        
    def initialize_db(self):
        """RSS ÏàòÏßëÏùÑ ÏúÑÌïú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # RSS Ï±ÑÎÑê ÌÖåÏù¥Î∏î
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS rss_channels (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                channel_id TEXT UNIQUE,
                channel_handle TEXT,
                title TEXT,
                rss_url TEXT,
                last_checked TEXT,
                is_active BOOLEAN DEFAULT 1,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # RSS ÎèôÏòÅÏÉÅ ÌÖåÏù¥Î∏î
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS rss_videos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                video_id TEXT UNIQUE,
                channel_id TEXT,
                title TEXT,
                description TEXT,
                published_at TEXT,
                thumbnail_url TEXT,
                video_url TEXT,
                duration TEXT,
                view_count INTEGER DEFAULT 0,
                like_count INTEGER DEFAULT 0,
                collected_at TEXT DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (channel_id) REFERENCES rss_channels (channel_id)
            )
        ''')
        
        # RSS ÌÇ§ÏõåÎìú ÌÖåÏù¥Î∏î
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS rss_keywords (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                keyword TEXT UNIQUE,
                is_active BOOLEAN DEFAULT 1,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def extract_channel_id_from_url(self, url: str) -> Optional[str]:
        """YouTube URLÏóêÏÑú Ï±ÑÎÑê ID Ï∂îÏ∂ú"""
        patterns = [
            r'youtube\.com/channel/([a-zA-Z0-9_-]+)',
            r'youtube\.com/c/([a-zA-Z0-9_-]+)',
            r'youtube\.com/@([a-zA-Z0-9_-]+)',
            r'youtube\.com/user/([a-zA-Z0-9_-]+)'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        
        return None
    
    def get_channel_handle_from_id(self, channel_id: str) -> Optional[str]:
        """Ï±ÑÎÑê IDÎ°úÎ∂ÄÌÑ∞ Ìï∏Îì§ Ï∂îÏ∂ú (RSS URL ÏÉùÏÑ±Ïö©)"""
        # Ï±ÑÎÑê IDÍ∞Ä Ïù¥ÎØ∏ Ìï∏Îì§ ÌòïÌÉúÏù∏ Í≤ΩÏö∞
        if channel_id.startswith('@'):
            return channel_id[1:]
        
        # Ï±ÑÎÑê IDÍ∞Ä UCÎ°ú ÏãúÏûëÌïòÎäî Í≤ΩÏö∞ (Ïã§Ï†ú Ï±ÑÎÑê ID)
        # Ïù¥ Í≤ΩÏö∞ RSS URLÏùÑ ÏßÅÏ†ë ÏÇ¨Ïö©
        return None
    
    def generate_rss_url(self, channel_identifier: str) -> str:
        """Ï±ÑÎÑê ÏãùÎ≥ÑÏûêÎ°úÎ∂ÄÌÑ∞ RSS URL ÏÉùÏÑ±"""
        if channel_identifier.startswith('UC'):
            # Ïã§Ï†ú Ï±ÑÎÑê IDÏù∏ Í≤ΩÏö∞
            return f"{self.base_rss_url}?channel_id={channel_identifier}"
        else:
            # Ìï∏Îì§Ïù¥Í±∞ÎÇò ÏÇ¨Ïö©ÏûêÎ™ÖÏù∏ Í≤ΩÏö∞
            return f"{self.base_rss_url}?user={channel_identifier}"
    
    def get_channel_id_from_handle(self, handle: str) -> str:
        """@Ìï∏Îì§ÏóêÏÑú Ïã§Ï†ú Ï±ÑÎÑê ID(UC...)Î•º Ï∂îÏ∂ú (Ïõπ Ïä§ÌÅ¨ÎûòÌïë)"""
        import requests
        import re
        if handle.startswith('@'):
            handle = handle[1:]
        
        url = f"https://www.youtube.com/@{handle}"
        print(f"üåê Ìï∏Îì§ ÌéòÏù¥ÏßÄ Ï†ëÏÜç: {url}")
        
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            resp = requests.get(url, timeout=10, headers=headers)
            print(f"üì° ÏùëÎãµ ÏÉÅÌÉú: {resp.status_code}")
            
            if resp.status_code == 200:
                # Ïó¨Îü¨ Ìå®ÌÑ¥ÏúºÎ°ú Ï±ÑÎÑê ID Ï∞æÍ∏∞
                patterns = [
                    r'"channelId":"(UC[^"]+)"',
                    r'"externalId":"(UC[^"]+)"',
                    r'channel_id=([^&"]+)',
                    r'data-channel-external-id="(UC[^"]+)"'
                ]
                
                for pattern in patterns:
                    match = re.search(pattern, resp.text)
                    if match:
                        channel_id = match.group(1)
                        if channel_id.startswith('UC'):
                            print(f"‚úÖ Ï±ÑÎÑê ID Î∞úÍ≤¨: {channel_id}")
                            return channel_id
                
                print("‚ùå Ï±ÑÎÑê IDÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
                return None
            else:
                print(f"‚ùå ÌéòÏù¥ÏßÄ Ï†ëÏÜç Ïã§Ìå®: {resp.status_code}")
                return None
                
        except Exception as e:
            print(f"‚ùå Ìï∏Îì§‚ÜíÏ±ÑÎÑêID Î≥ÄÌôò Ïã§Ìå®: {e}")
            return None
    
    def add_channel(self, channel_url: str, title: str = None) -> bool:
        """Ï±ÑÎÑê Ï∂îÍ∞Ä (Ìï∏Îì§ ÏßÄÏõê)"""
        try:
            # ÏûÖÎ†• Ï†ïÎ¶¨
            channel_url = channel_url.strip()
            
            # Ï±ÑÎÑê ID Ï∂îÏ∂ú
            channel_id = self.extract_channel_id_from_url(channel_url)
            
            if not channel_id:
                # @Ìï∏Îì§ ÏûÖÎ†• Ïãú Ï≤òÎ¶¨
                if channel_url.startswith('@') or '/@' in channel_url:
                    handle = channel_url.replace('https://www.youtube.com/', '').replace('@', '').replace('/', '')
                    print(f"üîç Ìï∏Îì§ÏóêÏÑú Ï±ÑÎÑê ID Ï∂îÏ∂ú Ï§ë: {handle}")
                    channel_id = self.get_channel_id_from_handle(handle)
                    if not channel_id:
                        st.error(f"Ìï∏Îì§ '@{handle}'ÏóêÏÑú Ï±ÑÎÑê IDÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Ïò¨Î∞îÎ•∏ Ìï∏Îì§Ïù∏ÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî.")
                        return False
                    print(f"‚úÖ Ìï∏Îì§ '{handle}' -> Ï±ÑÎÑê ID '{channel_id}' Î≥ÄÌôò ÏÑ±Í≥µ")
                else:
                    st.error("Ïú†Ìö®Ìïú YouTube Ï±ÑÎÑê URL ÎòêÎäî Ìï∏Îì§ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.")
                    return False
            
            # Ìï∏Îì§ Ï∂îÏ∂ú
            channel_handle = self.get_channel_handle_from_id(channel_id)
            
            # RSS URL ÏÉùÏÑ± Í∞úÏÑ†
            if channel_id.startswith('UC'):
                # Ïã§Ï†ú Ï±ÑÎÑê IDÏù∏ Í≤ΩÏö∞
                rss_url = f"{self.base_rss_url}?channel_id={channel_id}"
            else:
                # Ìï∏Îì§Ïù¥Í±∞ÎÇò ÏÇ¨Ïö©ÏûêÎ™ÖÏù∏ Í≤ΩÏö∞
                rss_url = f"{self.base_rss_url}?user={channel_id}"
            
            print(f"üîó ÏÉùÏÑ±Îêú RSS URL: {rss_url}")
            
            # RSS URL ÌÖåÏä§Ìä∏
            test_feed = feedparser.parse(rss_url)
            if hasattr(test_feed, 'status') and test_feed.status == 404:
                st.error(f"RSS ÌîºÎìúÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Ï±ÑÎÑê URLÏù¥ÎÇò Ìï∏Îì§ÏùÑ Îã§Ïãú ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.")
                print(f"‚ùå RSS URL ÌÖåÏä§Ìä∏ Ïã§Ìå®: {rss_url}")
                return False
            
            # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO rss_channels 
                (channel_id, channel_handle, title, rss_url, last_checked)
                VALUES (?, ?, ?, ?, ?)
            ''', (
                channel_id,
                channel_handle,
                title or f"Channel {channel_id}",
                rss_url,
                datetime.now().isoformat()
            ))
            
            conn.commit()
            conn.close()
            
            st.success(f"‚úÖ Ï±ÑÎÑê '{title or channel_id}'Ïù¥(Í∞Ä) Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.")
            print(f"‚úÖ Ï±ÑÎÑê Ï∂îÍ∞Ä ÏôÑÎ£å: {channel_id} -> {rss_url}")
            return True
            
        except Exception as e:
            st.error(f"Ï±ÑÎÑê Ï∂îÍ∞Ä Ïã§Ìå®: {str(e)}")
            print(f"‚ùå Ï±ÑÎÑê Ï∂îÍ∞Ä Ïò§Î•ò: {str(e)}")
            return False
    
    def add_keyword(self, keyword: str) -> bool:
        """ÌÇ§ÏõåÎìú Ï∂îÍ∞Ä"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO rss_keywords (keyword)
                VALUES (?)
            ''', (keyword,))
            
            conn.commit()
            conn.close()
            
            st.success(f"‚úÖ ÌÇ§ÏõåÎìú '{keyword}'Ïù¥(Í∞Ä) Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.")
            return True
            
        except Exception as e:
            st.error(f"ÌÇ§ÏõåÎìú Ï∂îÍ∞Ä Ïã§Ìå®: {str(e)}")
            return False
    
    def get_all_channels(self) -> List[Dict]:
        """Î™®Îì† RSS Ï±ÑÎÑê Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT id, channel_id, channel_handle, title, rss_url, 
                   last_checked, is_active, created_at
            FROM rss_channels
            ORDER BY created_at DESC
        ''')
        
        channels = []
        for row in cursor.fetchall():
            channels.append({
                'id': row[0],
                'channel_id': row[1],
                'channel_handle': row[2],
                'title': row[3],
                'rss_url': row[4],
                'last_checked': row[5],
                'is_active': bool(row[6]),
                'created_at': row[7]
            })
        
        conn.close()
        return channels
    
    def get_all_keywords(self) -> List[Dict]:
        """Î™®Îì† RSS ÌÇ§ÏõåÎìú Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT id, keyword, is_active, created_at
            FROM rss_keywords
            ORDER BY created_at DESC
        ''')
        
        keywords = []
        for row in cursor.fetchall():
            keywords.append({
                'id': row[0],
                'keyword': row[1],
                'is_active': bool(row[2]),
                'created_at': row[3]
            })
        
        conn.close()
        return keywords
    
    def fetch_channel_rss(self, channel_id: str, rss_url: str, days_back: int = 7) -> List[Dict]:
        """Ï±ÑÎÑê RSS ÌîºÎìú Í∞ÄÏ†∏Ïò§Í∏∞ (Í∏∞Í∞Ñ ÏßÄÏ†ï Í∞ÄÎä•)"""
        try:
            print(f"üîç RSS ÌîºÎìú Í∞ÄÏ†∏Ïò§Í∏∞: {channel_id} -> {rss_url}")
            
            # RSS ÌîºÎìú ÌååÏã±
            feed = feedparser.parse(rss_url)
            
            print(f"üì° RSS ÌîºÎìú ÏÉÅÌÉú: {feed.status if hasattr(feed, 'status') else 'Unknown'}")
            print(f"üìä RSS ÌîºÎìú Ìï≠Î™© Ïàò: {len(feed.entries)}")
            
            # Í∏∞Í∞Ñ ÌïÑÌÑ∞ÎßÅÏùÑ ÏúÑÌïú Í∏∞Ï§Ä ÏãúÍ∞Ñ
            cutoff_date = datetime.now() - timedelta(days=days_back)
            print(f"‚è∞ ÌïÑÌÑ∞ÎßÅ Í∏∞Ï§Ä ÏãúÍ∞Ñ: {cutoff_date}")
            
            videos = []
            for i, entry in enumerate(feed.entries):
                print(f"  üì∫ Ìï≠Î™© {i+1}: {entry.get('title', 'Ï†úÎ™© ÏóÜÏùå')}")
                
                # ÎπÑÎîîÏò§ ID Ï∂îÏ∂ú
                video_id = entry.get('yt_videoid')
                if not video_id:
                    # URLÏóêÏÑú ÎπÑÎîîÏò§ ID Ï∂îÏ∂ú
                    video_url = entry.get('link', '')
                    video_id_match = re.search(r'v=([a-zA-Z0-9_-]+)', video_url)
                    if video_id_match:
                        video_id = video_id_match.group(1)
                    else:
                        print(f"    ‚ùå ÎπÑÎîîÏò§ ID Ï∂îÏ∂ú Ïã§Ìå®: {video_url}")
                        continue
                
                print(f"    üÜî ÎπÑÎîîÏò§ ID: {video_id}")
                
                # Ïù¥ÎØ∏ ÏàòÏßëÎêú ÎπÑÎîîÏò§Ïù∏ÏßÄ ÌôïÏù∏
                if self.is_video_exists(video_id):
                    print(f"    ‚è≠Ô∏è Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÎπÑÎîîÏò§: {video_id}")
                    continue
                
                # Î∞úÌñâÏùº ÌååÏã± Î∞è Í∏∞Í∞Ñ ÌïÑÌÑ∞ÎßÅ
                published_str = entry.get('published', '')
                if published_str:
                    try:
                        # Îã§ÏñëÌïú RSS ÎÇ†Ïßú ÌòïÏãù ÏßÄÏõê
                        published_date = None
                        
                        # 1. ÌëúÏ§Ä RSS ÌòïÏãù: "Wed, 21 Jun 2023 10:30:00 +0000"
                        try:
                            published_date = datetime.strptime(published_str, "%a, %d %b %Y %H:%M:%S %z")
                        except ValueError:
                            pass
                        
                        # 2. ISO ÌòïÏãù: "2023-06-21T10:30:00+00:00"
                        if not published_date:
                            try:
                                published_date = datetime.fromisoformat(published_str.replace('Z', '+00:00'))
                            except ValueError:
                                pass
                        
                        # 3. Í∞ÑÎã®Ìïú ÌòïÏãù: "2023-06-21 10:30:00"
                        if not published_date:
                            try:
                                published_date = datetime.strptime(published_str, "%Y-%m-%d %H:%M:%S")
                            except ValueError:
                                pass
                        
                        # 4. ÎÇ†ÏßúÎßå: "2023-06-21"
                        if not published_date:
                            try:
                                published_date = datetime.strptime(published_str, "%Y-%m-%d")
                            except ValueError:
                                pass
                        
                        if published_date:
                            # timezone Ï†ïÎ≥¥ Ï†úÍ±∞ (naive datetimeÏúºÎ°ú Î≥ÄÌôò)
                            if published_date.tzinfo:
                                published_date = published_date.replace(tzinfo=None)
                            
                            print(f"    üìÖ Î∞úÌñâÏùº: {published_date}")
                            
                            # Í∏∞Í∞Ñ ÌïÑÌÑ∞ÎßÅ
                            if published_date < cutoff_date:
                                print(f"    ‚è∞ Í∏∞Í∞Ñ ÌïÑÌÑ∞ÎßÅ Ï†úÏô∏: {published_date} < {cutoff_date}")
                                continue
                        else:
                            print(f"    ‚ö†Ô∏è Ïïå Ïàò ÏóÜÎäî ÎÇ†Ïßú ÌòïÏãù: {published_str}")
                            published_date = datetime.now()
                            
                    except Exception as e:
                        # ÎÇ†Ïßú ÌååÏã± Ïã§Ìå® Ïãú ÌòÑÏû¨ ÏãúÍ∞ÑÏúºÎ°ú ÏÑ§Ï†ï
                        print(f"    ‚ö†Ô∏è ÎÇ†Ïßú ÌååÏã± Ïã§Ìå®: {e}")
                        published_date = datetime.now()
                else:
                    print(f"    ‚ö†Ô∏è Î∞úÌñâÏùº Ï†ïÎ≥¥ ÏóÜÏùå")
                    published_date = datetime.now()
                
                print(f"    ‚úÖ ÏÉà ÎπÑÎîîÏò§ Ï∂îÍ∞Ä: {entry.get('title', 'Ï†úÎ™© ÏóÜÏùå')}")
                
                # ÎπÑÎîîÏò§ Ï†ïÎ≥¥ Íµ¨ÏÑ±
                video_info = {
                    'video_id': video_id,
                    'channel_id': channel_id,
                    'title': entry.get('title', ''),
                    'description': entry.get('summary', ''),
                    'published_at': published_date.isoformat(),
                    'thumbnail_url': entry.get('media_thumbnail', [{}])[0].get('url', ''),
                    'video_url': entry.get('link', ''),
                    'duration': entry.get('media_content', [{}])[0].get('duration', ''),
                    'view_count': 0,  # RSSÏóêÏÑúÎäî Ï†úÍ≥µÎêòÏßÄ ÏïäÏùå
                    'like_count': 0   # RSSÏóêÏÑúÎäî Ï†úÍ≥µÎêòÏßÄ ÏïäÏùå
                }
                
                videos.append(video_info)
            
            print(f"üéØ ÏµúÏ¢Ö ÏàòÏßëÎêú ÎπÑÎîîÏò§: {len(videos)}Í∞ú")
            return videos
            
        except Exception as e:
            print(f"‚ùå RSS ÌîºÎìú Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå® ({channel_id}): {str(e)}")
            return []
    
    def is_video_exists(self, video_id: str) -> bool:
        """ÎπÑÎîîÏò§Í∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('SELECT 1 FROM rss_videos WHERE video_id = ?', (video_id,))
        exists = cursor.fetchone() is not None
        
        conn.close()
        return exists
    
    def save_videos(self, videos: List[Dict]) -> int:
        """ÎπÑÎîîÏò§ Ï†ïÎ≥¥ Ï†ÄÏû•"""
        if not videos:
            return 0
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        saved_count = 0
        for video in videos:
            try:
                cursor.execute('''
                    INSERT OR IGNORE INTO rss_videos 
                    (video_id, channel_id, title, description, published_at, 
                     thumbnail_url, video_url, duration, view_count, like_count)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    video['video_id'],
                    video['channel_id'],
                    video['title'],
                    video['description'],
                    video['published_at'],
                    video['thumbnail_url'],
                    video['video_url'],
                    video['duration'],
                    video['view_count'],
                    video['like_count']
                ))
                
                if cursor.rowcount > 0:
                    saved_count += 1
                    
            except Exception as e:
                st.warning(f"ÎπÑÎîîÏò§ Ï†ÄÏû• Ïã§Ìå® ({video['video_id']}): {str(e)}")
        
        conn.commit()
        conn.close()
        
        return saved_count
    
    def update_channel_last_checked(self, channel_id: str):
        """Ï±ÑÎÑê ÎßàÏßÄÎßâ Ï≤¥ÌÅ¨ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            UPDATE rss_channels 
            SET last_checked = ? 
            WHERE channel_id = ?
        ''', (datetime.now().isoformat(), channel_id))
        
        conn.commit()
        conn.close()
    
    def collect_all_channels(self) -> Dict:
        """Î™®Îì† Ï±ÑÎÑêÏóêÏÑú RSS ÏàòÏßë"""
        channels = self.get_all_channels()
        active_channels = [c for c in channels if c['is_active']]
        
        if not active_channels:
            st.warning("ÌôúÏÑ±ÌôîÎêú RSS Ï±ÑÎÑêÏù¥ ÏóÜÏäµÎãàÎã§.")
            return {'total_channels': 0, 'total_videos': 0, 'new_videos': 0}
        
        st.info(f"üì° {len(active_channels)}Í∞ú Ï±ÑÎÑêÏóêÏÑú RSS ÌîºÎìúÎ•º ÏàòÏßëÌï©ÎãàÎã§...")
        
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        total_videos = 0
        total_new_videos = 0
        
        for i, channel in enumerate(active_channels):
            status_text.text(f"Ï±ÑÎÑê '{channel['title']}' Ï≤òÎ¶¨ Ï§ë... ({i+1}/{len(active_channels)})")
            
            # RSS ÌîºÎìú Í∞ÄÏ†∏Ïò§Í∏∞ (Í∏∞Î≥∏ 7Ïùº)
            videos = self.fetch_channel_rss(channel['channel_id'], channel['rss_url'], days_back=7)
            
            if videos:
                # ÏÉà ÎπÑÎîîÏò§ Ï†ÄÏû•
                new_videos = self.save_videos(videos)
                total_videos += len(videos)
                total_new_videos += new_videos
                
                # ÎßàÏßÄÎßâ Ï≤¥ÌÅ¨ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
                self.update_channel_last_checked(channel['channel_id'])
                
                st.success(f"‚úÖ {channel['title']}: {len(videos)}Í∞ú ÎπÑÎîîÏò§, {new_videos}Í∞ú ÏÉà ÎπÑÎîîÏò§")
            else:
                st.info(f"‚ÑπÔ∏è {channel['title']}: ÏÉà ÎπÑÎîîÏò§ ÏóÜÏùå")
            
            # ÏßÑÌñâÎ•† ÏóÖÎç∞Ïù¥Ìä∏
            progress = (i + 1) / len(active_channels)
            progress_bar.progress(progress)
        
        status_text.text("ÏôÑÎ£å!")
        
        result = {
            'total_channels': len(active_channels),
            'total_videos': total_videos,
            'new_videos': total_new_videos
        }
        
        st.success(f"üéâ RSS ÏàòÏßë ÏôÑÎ£å! {result['new_videos']}Í∞ú ÏÉà ÎπÑÎîîÏò§ Î∞úÍ≤¨")
        return result
    
    def collect_channels_with_period(self, days_back: int = 30) -> Dict:
        """ÏßÄÏ†ïÎêú Í∏∞Í∞Ñ ÎèôÏïà Î™®Îì† Ï±ÑÎÑêÏóêÏÑú RSS ÏàòÏßë"""
        channels = self.get_all_channels()
        active_channels = [c for c in channels if c['is_active']]
        
        if not active_channels:
            st.warning("ÌôúÏÑ±ÌôîÎêú RSS Ï±ÑÎÑêÏù¥ ÏóÜÏäµÎãàÎã§.")
            return {'total_channels': 0, 'total_videos': 0, 'new_videos': 0}
        
        st.info(f"üì° {len(active_channels)}Í∞ú Ï±ÑÎÑêÏóêÏÑú ÏµúÍ∑º {days_back}ÏùºÍ∞ÑÏùò RSS ÌîºÎìúÎ•º ÏàòÏßëÌï©ÎãàÎã§...")
        
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        total_videos = 0
        total_new_videos = 0
        
        for i, channel in enumerate(active_channels):
            status_text.text(f"Ï±ÑÎÑê '{channel['title']}' Ï≤òÎ¶¨ Ï§ë... ({i+1}/{len(active_channels)})")
            
            # RSS ÌîºÎìú Í∞ÄÏ†∏Ïò§Í∏∞ (ÏßÄÏ†ïÎêú Í∏∞Í∞Ñ)
            videos = self.fetch_channel_rss(channel['channel_id'], channel['rss_url'], days_back=days_back)
            
            if videos:
                # ÏÉà ÎπÑÎîîÏò§ Ï†ÄÏû•
                new_videos = self.save_videos(videos)
                total_videos += len(videos)
                total_new_videos += new_videos
                
                # ÎßàÏßÄÎßâ Ï≤¥ÌÅ¨ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
                self.update_channel_last_checked(channel['channel_id'])
                
                st.success(f"‚úÖ {channel['title']}: {len(videos)}Í∞ú ÎπÑÎîîÏò§, {new_videos}Í∞ú ÏÉà ÎπÑÎîîÏò§")
            else:
                st.info(f"‚ÑπÔ∏è {channel['title']}: ÏÉà ÎπÑÎîîÏò§ ÏóÜÏùå")
            
            # ÏßÑÌñâÎ•† ÏóÖÎç∞Ïù¥Ìä∏
            progress = (i + 1) / len(active_channels)
            progress_bar.progress(progress)
        
        status_text.text("ÏôÑÎ£å!")
        
        result = {
            'total_channels': len(active_channels),
            'total_videos': total_videos,
            'new_videos': total_new_videos,
            'days_back': days_back
        }
        
        st.success(f"üéâ RSS ÏàòÏßë ÏôÑÎ£å! ÏµúÍ∑º {days_back}ÏùºÍ∞Ñ {result['new_videos']}Í∞ú ÏÉà ÎπÑÎîîÏò§ Î∞úÍ≤¨")
        return result
    
    def sync_with_main_db(self) -> Dict:
        """RSS ÏàòÏßë Îç∞Ïù¥ÌÑ∞Î•º Î©îÏù∏ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏôÄ ÎèôÍ∏∞Ìôî"""
        try:
            # RSS ÎπÑÎîîÏò§Î•º Î©îÏù∏ videos ÌÖåÏù¥Î∏îÎ°ú Î≥µÏÇ¨
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # RSS ÎπÑÎîîÏò§ Ï§ë Î©îÏù∏ ÌÖåÏù¥Î∏îÏóê ÏóÜÎäî Í≤ÉÎì§ Í∞ÄÏ†∏Ïò§Í∏∞
            cursor.execute('''
                SELECT rv.video_id, rv.title, rv.channel_id, rc.title as channel_title,
                       rv.published_at, rv.description, rv.video_url
                FROM rss_videos rv
                JOIN rss_channels rc ON rv.channel_id = rc.channel_id
                WHERE rv.video_id NOT IN (SELECT id FROM videos)
            ''')
            
            new_videos = cursor.fetchall()
            
            # Î©îÏù∏ ÌÖåÏù¥Î∏îÏóê ÏÇΩÏûÖ
            synced_count = 0
            for video in new_videos:
                try:
                    cursor.execute('''
                        INSERT INTO videos (id, title, channel_id, channel_title, 
                                          published_at, duration, view_count, 
                                          transcript, url, created_at)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        video[0],  # video_id
                        video[1],  # title
                        video[2],  # channel_id
                        video[3],  # channel_title
                        video[4],  # published_at
                        'PT0S',    # duration (RSSÏóêÏÑúÎäî Ï†úÍ≥µÎêòÏßÄ ÏïäÏùå)
                        0,         # view_count (RSSÏóêÏÑúÎäî Ï†úÍ≥µÎêòÏßÄ ÏïäÏùå)
                        video[5],  # descriptionÏùÑ transcriptÎ°ú ÏÇ¨Ïö©
                        video[6],  # video_url
                        datetime.now().isoformat()
                    ))
                    synced_count += 1
                except Exception as e:
                    st.warning(f"ÎπÑÎîîÏò§ ÎèôÍ∏∞Ìôî Ïã§Ìå® ({video[0]}): {str(e)}")
            
            conn.commit()
            conn.close()
            
            result = {
                'total_rss_videos': len(new_videos),
                'synced_videos': synced_count
            }
            
            st.success(f"‚úÖ Î©îÏù∏ DB ÎèôÍ∏∞Ìôî ÏôÑÎ£å! {synced_count}Í∞ú ÎπÑÎîîÏò§ ÎèôÍ∏∞ÌôîÎê®")
            return result
            
        except Exception as e:
            st.error(f"Î©îÏù∏ DB ÎèôÍ∏∞Ìôî Ïã§Ìå®: {str(e)}")
            return {'total_rss_videos': 0, 'synced_videos': 0}
    
    def get_videos_by_date_range(self, start_date: str, end_date: str) -> List[Dict]:
        """ÌäπÏ†ï ÎÇ†Ïßú Î≤îÏúÑÏùò ÎπÑÎîîÏò§ Í∞ÄÏ†∏Ïò§Í∏∞"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT v.*, c.title as channel_title
                FROM rss_videos v
                JOIN rss_channels c ON v.channel_id = c.channel_id
                WHERE v.published_at >= ? AND v.published_at <= ?
                ORDER BY v.published_at DESC
            ''', (start_date, end_date))
            
            videos = []
            for row in cursor.fetchall():
                videos.append({
                    'video_id': row[1],
                    'channel_id': row[2],
                    'title': row[3],
                    'description': row[4],
                    'published_at': row[5],
                    'thumbnail_url': row[6],
                    'video_url': row[7],
                    'duration': row[8],
                    'view_count': row[9],
                    'like_count': row[10],
                    'channel_title': row[12]
                })
            
            conn.close()
            return videos
            
        except Exception as e:
            st.error(f"ÎÇ†Ïßú Î≤îÏúÑ Í≤ÄÏÉâ Ïã§Ìå®: {str(e)}")
            return []
    
    def get_recent_videos(self, hours: int = 24, limit: int = 50) -> List[Dict]:
        """ÏµúÍ∑º ÎπÑÎîîÏò§ Í∞ÄÏ†∏Ïò§Í∏∞"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cutoff_time = datetime.now() - timedelta(hours=hours)
        
        cursor.execute('''
            SELECT v.*, c.title as channel_title
            FROM rss_videos v
            JOIN rss_channels c ON v.channel_id = c.channel_id
            WHERE v.published_at >= ?
            ORDER BY v.published_at DESC
            LIMIT ?
        ''', (cutoff_time.isoformat(), limit))
        
        videos = []
        for row in cursor.fetchall():
            videos.append({
                'video_id': row[1],
                'channel_id': row[2],
                'title': row[3],
                'description': row[4],
                'published_at': row[5],
                'thumbnail_url': row[6],
                'video_url': row[7],
                'duration': row[8],
                'view_count': row[9],
                'like_count': row[10],
                'channel_title': row[12]
            })
        
        conn.close()
        return videos
    
    def search_videos_by_keyword(self, keyword: str, hours: int = 24) -> List[Dict]:
        """ÌÇ§ÏõåÎìúÎ°ú ÎπÑÎîîÏò§ Í≤ÄÏÉâ"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cutoff_time = datetime.now() - timedelta(hours=hours)
        
        cursor.execute('''
            SELECT v.*, c.title as channel_title
            FROM rss_videos v
            JOIN rss_channels c ON v.channel_id = c.channel_id
            WHERE (v.title LIKE ? OR v.description LIKE ?)
            AND v.published_at >= ?
            ORDER BY v.published_at DESC
        ''', (f'%{keyword}%', f'%{keyword}%', cutoff_time.isoformat()))
        
        videos = []
        for row in cursor.fetchall():
            videos.append({
                'video_id': row[1],
                'channel_id': row[2],
                'title': row[3],
                'description': row[4],
                'published_at': row[5],
                'thumbnail_url': row[6],
                'video_url': row[7],
                'duration': row[8],
                'view_count': row[9],
                'like_count': row[10],
                'channel_title': row[12]
            })
        
        conn.close()
        return videos
    
    def delete_channel(self, channel_id: str) -> bool:
        """Ï±ÑÎÑê ÏÇ≠Ï†ú"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute('DELETE FROM rss_channels WHERE channel_id = ?', (channel_id,))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"Ï±ÑÎÑê ÏÇ≠Ï†ú Ïã§Ìå®: {e}")
            return False
    
    def delete_keyword(self, keyword: str) -> bool:
        """ÌÇ§ÏõåÎìú ÏÇ≠Ï†ú"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute('DELETE FROM rss_keywords WHERE keyword = ?', (keyword,))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"ÌÇ§ÏõåÎìú ÏÇ≠Ï†ú Ïã§Ìå®: {e}")
            return False

# Ï†ÑÏó≠ Ïù∏Ïä§ÌÑ¥Ïä§
rss_collector = YouTubeRSSCollector()

def main():
    """RSS ÏàòÏßëÍ∏∞ Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    print("üéØ YouTube RSS ÏàòÏßëÍ∏∞ ÏãúÏûë")
    
    # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî
    rss_collector.initialize_db()
    print("‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    # Îì±Î°ùÎêú Ï±ÑÎÑê ÌôïÏù∏
    channels = rss_collector.get_all_channels()
    print(f"üì∫ Îì±Î°ùÎêú Ï±ÑÎÑê: {len(channels)}Í∞ú")
    for channel in channels:
        print(f"  - {channel['title']} ({channel['channel_id']})")
    
    # Îì±Î°ùÎêú ÌÇ§ÏõåÎìú ÌôïÏù∏
    keywords = rss_collector.get_all_keywords()
    print(f"üîç Îì±Î°ùÎêú ÌÇ§ÏõåÎìú: {len(keywords)}Í∞ú")
    for keyword in keywords:
        print(f"  - {keyword['keyword']}")
    
    if channels:
        print("\nüì° RSS ÌîºÎìú ÏàòÏßë ÏãúÏûë...")
        
        # ÏÇ¨Ïö©Ïûê ÏûÖÎ†•ÏúºÎ°ú Í∏∞Í∞Ñ ÏÑ†ÌÉù
        import sys
        if len(sys.argv) > 1:
            try:
                days_back = int(sys.argv[1])
                print(f"ÏßÄÏ†ïÎêú Í∏∞Í∞Ñ: ÏµúÍ∑º {days_back}Ïùº")
                result = rss_collector.collect_channels_with_period(days_back)
            except ValueError:
                print("Í∏∞Î≥∏ Í∏∞Í∞Ñ ÏÇ¨Ïö©: ÏµúÍ∑º 7Ïùº")
                result = rss_collector.collect_all_channels()
        else:
            print("Í∏∞Î≥∏ Í∏∞Í∞Ñ ÏÇ¨Ïö©: ÏµúÍ∑º 7Ïùº")
            result = rss_collector.collect_all_channels()
        
        print(f"‚úÖ ÏàòÏßë ÏôÑÎ£å: {result['new_videos']}Í∞ú ÏÉà ÎπÑÎîîÏò§")
        
        # Î©îÏù∏ DBÏôÄ ÎèôÍ∏∞Ìôî
        print("\nüîÑ Î©îÏù∏ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏôÄ ÎèôÍ∏∞Ìôî Ï§ë...")
        sync_result = rss_collector.sync_with_main_db()
        print(f"‚úÖ ÎèôÍ∏∞Ìôî ÏôÑÎ£å: {sync_result['synced_videos']}Í∞ú ÎπÑÎîîÏò§ ÎèôÍ∏∞ÌôîÎê®")
    else:
        print("‚ö†Ô∏è Îì±Î°ùÎêú Ï±ÑÎÑêÏù¥ ÏóÜÏäµÎãàÎã§.")
    
    if keywords:
        print("\nüîç ÌÇ§ÏõåÎìú Í≤ÄÏÉâ Í≤∞Í≥º:")
        for keyword in keywords:
            videos = rss_collector.search_videos_by_keyword(keyword['keyword'], hours=24)
            print(f"  - '{keyword['keyword']}': {len(videos)}Í∞ú ÎπÑÎîîÏò§")
            for video in videos[:3]:  # ÏµúÎåÄ 3Í∞úÎßå ÌëúÏãú
                print(f"    * {video['title']} ({video['channel_title']})")

if __name__ == "__main__":
    main() 